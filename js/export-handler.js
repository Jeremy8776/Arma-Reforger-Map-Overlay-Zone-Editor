/**
 * Arma Reforger Map Overlay Zone Editor
 * Export Handler - Generates various export formats
 */

class ExportHandler {
    constructor(core, zoneManager) {
        this.core = core;
        this.zoneManager = zoneManager;
    }

    /**
     * Export zones in the specified format
     */
    export(format, settings = {}) {
        const zones = this.zoneManager.getZones();

        if (zones.length === 0) {
            alert('No zones to export. Create some zones first!');
            return;
        }

        const scale = settings.mapScale || 1;
        const originX = settings.originX || 0;
        const originY = settings.originY || 0;

        // Transform coordinates based on settings
        const transformedZones = zones.map(zone => this.transformZone(zone, scale, originX, originY));

        switch (format) {
            case 'enfusion':
                this.exportEnfusion(transformedZones);
                break;
            case 'json':
                this.exportJSON(transformedZones);
                break;
            case 'image':
                this.exportImage(settings);
                break;
            case 'tiff':
                this.exportTIFF(settings);
                break;
            case 'workbench':
                this.exportWorkbenchPlugin(transformedZones);
                break;
            case 'all':
                this.exportAll(transformedZones, settings);
                break;
        }
    }

    /**
     * Transform zone coordinates based on map scale and origin
     */
    transformZone(zone, scale, originX, originY) {
        const transformed = { ...zone };

        // Scale and translate based on available properties
        if (transformed.cx !== undefined) {
            transformed.cx = (transformed.cx * scale) + originX;
            transformed.cy = (transformed.cy * scale) + originY;
            transformed.radius = transformed.radius * scale;
        }

        if (transformed.x !== undefined) {
            transformed.x = (transformed.x * scale) + originX;
            transformed.y = (transformed.y * scale) + originY;
        }

        if (transformed.width !== undefined) {
            transformed.width = transformed.width * scale;
            transformed.height = transformed.height * scale;
        }

        if (transformed.points) {
            transformed.points = transformed.points.map(p => ({
                x: (p.x * scale) + originX,
                y: (p.y * scale) + originY
            }));
        }

        return transformed;
    }

    /**
     * Export as EnfusionScript format
     */
    /**
     * Export as EnfusionScript format (GameModeComponent)
     */
    exportEnfusion(zones) {
        const timestamp = new Date().toISOString();

        let script = `// ============================================
// Arma Reforger Zone Definitions
// Generated by Zone Editor
// Date: ${timestamp}
// ============================================

// Zone Type Enumeration
enum EZoneType
{
    SAFE,
    RESTRICTED,
    PVP,
    SPAWN,
    OBJECTIVE,
    CUSTOM
}

// Zone Definition Class
class ZoneDefinition
{
    string Name;
    EZoneType Type;
    string Shape;
    ref array<vector> Points;
    vector Center;
    float Radius;
    int Color;
    float Opacity;
    
    void ZoneDefinition(string name, EZoneType type, string shape)
    {
        Name = name;
        Type = type;
        Shape = shape;
        Points = new array<vector>();
    }
    
    bool ContainsPoint(vector pos)
    {
        if (Shape == "circle")
        {
            return vector.Distance(pos, Center) <= Radius;
        }
        else
        {
            return PointInPolygon(pos);
        }
    }
    
    protected bool PointInPolygon(vector point)
    {
        bool inside = false;
        int count = Points.Count();
        
        for (int i = 0, j = count - 1; i < count; j = i++)
        {
            vector pi = Points[i];
            vector pj = Points[j];
            
            if (((pi[2] > point[2]) != (pj[2] > point[2])) &&
                (point[0] < (pj[0] - pi[0]) * (point[2] - pi[2]) / (pj[2] - pi[2]) + pi[0]))
            {
                inside = !inside;
            }
        }
        
        return inside;
    }
}

// Zone Manager Component
// Add this component to your SCR_BaseGameMode entity in World Editor
[ComponentEditorProps(category: "Game Mode Component", description: "Manages custom map zones")]
class SCR_ZoneManagerComponentClass: SCR_BaseGameModeComponentClass
{
}

class SCR_ZoneManagerComponent: SCR_BaseGameModeComponent
{
    protected ref array<ref ZoneDefinition> m_Zones;
    protected static SCR_ZoneManagerComponent s_Instance;

    // Get the global instance
    static SCR_ZoneManagerComponent GetInstance()
    {
        if (!s_Instance)
        {
            SCR_BaseGameMode gameMode = SCR_BaseGameMode.Cast(GetGame().GetGameMode());
            if (gameMode)
                s_Instance = SCR_ZoneManagerComponent.Cast(gameMode.FindComponent(SCR_ZoneManagerComponent));
        }
        return s_Instance;
    }

    override void OnGameModeStart()
    {
        super.OnGameModeStart();
        s_Instance = this;
        InitZones();
        Print("[ZoneManager] Zones initialized.", LogLevel.NORMAL);
    }
    
    protected void InitZones()
    {
        m_Zones = new array<ref ZoneDefinition>();
        
`;

        // Add zone definitions
        for (const zone of zones) {
            const typeEnum = this.getEnfusionType(zone.type);
            const colorInt = this.hexToInt(zone.color);

            script += `        // ${zone.name}\n`;
            script += `        {\n`;
            script += `            ZoneDefinition zone = new ZoneDefinition("${this.escapeString(zone.name)}", ${typeEnum}, "${zone.shape}");\n`;

            if (zone.shape === 'circle') {
                script += `            zone.Center = Vector(${zone.cx.toFixed(2)}, 0, ${zone.cy.toFixed(2)});\n`;
                script += `            zone.Radius = ${zone.radius.toFixed(2)};\n`;
            } else if (zone.points) {
                for (const point of zone.points) {
                    script += `            zone.Points.Insert(Vector(${point.x.toFixed(2)}, 0, ${point.y.toFixed(2)}));\n`;
                }
            }

            script += `            zone.Color = ${colorInt};\n`;
            script += `            zone.Opacity = ${zone.opacity.toFixed(2)};\n`;
            script += `            m_Zones.Insert(zone);\n`;
            script += `        }\n\n`;
        }

        script += `    }
    
    ZoneDefinition GetZoneAtPosition(vector pos)
    {
        if (!m_Zones) return null;
        
        foreach (ZoneDefinition zone : m_Zones)
        {
            if (zone.ContainsPoint(pos))
                return zone;
        }
        return null;
    }
    
    bool IsInSafeZone(vector pos)
    {
        ZoneDefinition zone = GetZoneAtPosition(pos);
        return zone && zone.Type == EZoneType.SAFE;
    }
    
    bool IsInRestrictedZone(vector pos)
    {
        ZoneDefinition zone = GetZoneAtPosition(pos);
        return zone && zone.Type == EZoneType.RESTRICTED;
    }
    
    array<ref ZoneDefinition> GetAllZones()
    {
        return m_Zones;
    }
}
`;

        Utils.downloadFile(script, 'SCR_ZoneManagerComponent.c', 'text/plain');
    }

    /**
     * Export as JSON format
     */
    exportJSON(zones) {
        const exportData = {
            version: "1.0",
            generated: new Date().toISOString(),
            generator: "Arma Reforger Zone Editor",
            mapInfo: {
                width: this.core.mapWidth,
                height: this.core.mapHeight
            },
            zones: zones.map(zone => {
                const zoneData = {
                    id: zone.id,
                    name: zone.name,
                    type: zone.type,
                    shape: zone.shape,
                    color: zone.color,
                    opacity: zone.opacity,
                    visible: zone.visible
                };

                if (zone.shape === 'circle') {
                    zoneData.center = { x: zone.cx, y: zone.cy };
                    zoneData.radius = zone.radius;
                }

                if (zone.points) {
                    zoneData.points = zone.points.map(p => ({ x: p.x, y: p.y }));

                    // Also include bounds for convenience
                    const bounds = Utils.getPolygonBounds(zone.points);
                    zoneData.bounds = bounds;
                }

                return zoneData;
            })
        };

        const json = JSON.stringify(exportData, null, 2);
        Utils.downloadFile(json, 'zones.json', 'application/json');
    }

    /**
     * Export as PNG image overlay (Enfusion-compatible)
     * Following Arma Reforger texture guidelines:
     * - Power of 2 dimensions recommended
     * - Proper suffix naming (_A for alpha/opacity, _BCR for color+roughness)
     * - 8-bit per channel
     */
    exportImage(settings = {}) {
        const canvas = this.renderer.exportAsImage();
        if (!canvas) return;

        // Get export settings
        const suffix = settings.textureSuffix || '_A'; // Default to opacity mask
        const resizeToPow2 = settings.resizeToPow2 !== false;
        const baseName = settings.baseName || 'zone_overlay';

        let exportCanvas = canvas;

        // Optionally resize to power of 2 for better Enfusion compatibility
        if (resizeToPow2) {
            exportCanvas = this.resizeToPowerOf2(canvas);
        }

        // Generate filename with proper Enfusion suffix
        const filename = `${baseName}${suffix}.png`;

        Utils.downloadCanvas(exportCanvas, filename);

        // Also provide instructions
        console.log(`
=== Enfusion Import Instructions ===
1. Place ${filename} in your mod's data folder
2. In Resource Browser, right-click â†’ Register and Import
3. The '${suffix}' suffix will auto-configure import settings:
   ${this.getSuffixDescription(suffix)}
4. After import, an .edds file will be created
================================
        `);
    }

    /**
     * Export as TIFF image overlay
     */
    exportTIFF(settings = {}) {
        const canvas = this.renderer.exportAsImage();
        if (!canvas) return;

        // Get export settings
        const suffix = settings.textureSuffix || '_A';
        const resizeToPow2 = settings.resizeToPow2 !== false;
        const baseName = settings.baseName || 'zone_overlay';

        let exportCanvas = canvas;
        if (resizeToPow2) {
            exportCanvas = this.resizeToPowerOf2(canvas);
        }

        const ctx = exportCanvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);

        // Convert RGBA to TIFF format using UTIF
        const tiffData = UTIF.encodeImage(imageData.data, exportCanvas.width, exportCanvas.height);

        // Create binary blob
        const blob = new Blob([tiffData], { type: 'image/tiff' });
        const url = URL.createObjectURL(blob);

        const filename = `${baseName}${suffix}.tiff`;

        // Helper to trigger download
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    /**
     * Resize canvas to nearest power of 2 dimensions
     */
    resizeToPowerOf2(sourceCanvas) {
        const nextPow2 = (n) => Math.pow(2, Math.ceil(Math.log2(n)));

        const newWidth = nextPow2(sourceCanvas.width);
        const newHeight = nextPow2(sourceCanvas.height);

        // If already power of 2, return original
        if (newWidth === sourceCanvas.width && newHeight === sourceCanvas.height) {
            return sourceCanvas;
        }

        const resizedCanvas = document.createElement('canvas');
        resizedCanvas.width = newWidth;
        resizedCanvas.height = newHeight;
        const ctx = resizedCanvas.getContext('2d');

        // Clear with transparency
        ctx.clearRect(0, 0, newWidth, newHeight);

        // Draw original centered or scaled
        ctx.drawImage(sourceCanvas, 0, 0, newWidth, newHeight);

        return resizedCanvas;
    }

    /**
     * Get description for texture suffix
     */
    getSuffixDescription(suffix) {
        const descriptions = {
            '_A': 'Opacity mask - Red channel only, linear RGB, RedHQCompression',
            '_BCR': 'Base Color + Roughness - RGB + Alpha, sRGB, ColorHQCompression',
            '_BCA': 'Base Color + Opacity - RGB + Alpha, sRGB, ColorHQCompression',
            '_BC': 'Base Color only - RGB, sRGB, ColorHQCompression'
        };
        return descriptions[suffix] || 'Custom texture type';
    }

    /**
     * Export all formats as separate files
     */
    exportAll(zones, settings = {}) {
        // Since we can't create a ZIP without a library, download them separately
        // with a small delay between each

        this.exportEnfusion(zones);

        setTimeout(() => {
            this.exportJSON(zones);
        }, 500);

        setTimeout(() => {
            this.exportImage(settings);
        }, 1000);
    }

    /**
     * Get Enfusion enum type string
     */
    getEnfusionType(type) {
        const types = {
            'safe': 'EZoneType.SAFE',
            'restricted': 'EZoneType.RESTRICTED',
            'pvp': 'EZoneType.PVP',
            'spawn': 'EZoneType.SPAWN',
            'objective': 'EZoneType.OBJECTIVE',
            'custom': 'EZoneType.CUSTOM'
        };
        return types[type] || 'EZoneType.CUSTOM';
    }

    /**
     * Convert hex color to integer
     */
    hexToInt(hex) {
        return parseInt(hex.replace('#', ''), 16);
    }



    /**
     * Export as Enfusion Workbench Plugin
     * Allows devs to spawn entities directly in World Editor
     */
    exportWorkbenchPlugin(zones) {
        let script = `[WorkbenchPluginAttribute(name: "Import Zones from Editor", shortcut: "Ctrl+Shift+I", icon: "infopoint")]
class ImportZonesPlugin : WorkbenchPlugin
{
    override void Run()
    {
        WorldEditorAPI api = GenericComponent.GetWorldEditorAPI();
        if (!api) return;
        
        api.BeginEntityAction("ImportZones");
        
        // Zone Data
`;

        // We embed the data directly in the script to avoid file I/O issues in Workbench
        for (const zone of zones) {
            const typeStr = zone.type.toUpperCase();

            // Calculate center and radius/size based on shape type
            let cx = 0, cy = 0, radius = 0, width = 0, height = 0;
            let shapeType = "box"; // Default to box for non-circles

            if (zone.shape === 'circle') {
                cx = zone.cx;
                cy = zone.cy;
                radius = zone.radius;
                shapeType = "circle";
            } else if (zone.shape === 'rectangle') {
                cx = zone.x + zone.width / 2;
                cy = zone.y + zone.height / 2;
                width = zone.width;
                height = zone.height;
                // Approximate radius for fallback
                radius = Math.max(width, height) / 2;
                shapeType = "box";
            } else if (zone.points) {
                // Polygon / Line / Freehand
                const bounds = Utils.getPolygonBounds(zone.points);
                if (bounds) {
                    cx = bounds.x + bounds.width / 2;
                    cy = bounds.y + bounds.height / 2;
                    width = bounds.width;
                    height = bounds.height;
                    radius = Math.max(width, height) / 2;
                }
                shapeType = "box";
            }

            // Ensure values are numbers (handle undefined/NaN)
            cx = (isFinite(cx)) ? cx : 0;
            cy = (isFinite(cy)) ? cy : 0;
            radius = (isFinite(radius)) ? radius : 1;

            script += `        CreateZone(api, "${this.escapeString(zone.name)}", "${shapeType}", ${cx.toFixed(2)}, ${cy.toFixed(2)}, ${radius.toFixed(2)}, "${typeStr}");\n`;
        }

        script += `
        api.EndEntityAction();
    }
    
    void CreateZone(WorldEditorAPI api, string name, string shape, float x, float z, float radius, string type)
    {
        // Create a Trigger Entity
        // Note: You may want to change "SCR_BaseTriggerEntity" to your specific custom trigger prefab if you have one
        IEntitySource source = api.CreateEntity("SCR_BaseTriggerEntity", "", api.GetWorld().GetRootEntitySource());
        
        // Set coordinates (Y is height, set to 0 or adjust as needed)
        vector mat[4];
        mat[3] = Vector(x, 0, z); // Position
        source.Set("coords", string.Format("%1 %2 %3", mat[3][0], mat[3][1], mat[3][2]));
        
        // Set Name
        api.RenameEntity(source, name);
        
        // Set properties based on shape
        if (shape == "circle")
        {
            api.ModifyEntityKey(source, "SphereRadius", radius.ToString());
            api.ModifyEntityKey(source, "Shape", "Sphere");
        }
        else
        {
            api.ModifyEntityKey(source, "Shape", "Box");
            // Set sphere radius as fallback/reference for visualization
             api.ModifyEntityKey(source, "SphereRadius", radius.ToString());
        }
        
        Print("Created Zone: " + name);
    }
}
`;
        Utils.downloadFile(script, 'ImportZonesPlugin.c', 'text/plain');
    }

    /**
     * Escape string for use in script
     */
    /**
     * Escape string for use in script
     */
    escapeString(str) {
        return str.replace(/"/g, '\\"').replace(/\n/g, '\\n');
    }
}

// Export for use in other modules
window.ExportHandler = ExportHandler;
